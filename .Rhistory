cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- inverse(data, ...)
x$setmean(m)
m
}
cachemean(x)
a<-makeVector(vec)
cachemean(vec,a)
cachemean(a)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
a<-makeVector(vec)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(a)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(a)
vec<-c(1:100)
cachemean(a)
a<-makeVector(vec)
cachemean(a)
vec<-c(1:400)
cachemean(a)
cachemean(a)
## Write a short comment describing this function
cachemean(a)
a<-makeVector(vec)
cachemean(a)
cachemean((makeVector(vec)))
bd<-cachemean((makeVector(vec)))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(solve) m <<- inverse
getmean <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- inverse(data, ...)
x$setinverse(m)
m
}
cacheSolve(cachemean(x))
cacheSolve(makeCacheMatrix(x))
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) { #The object x, taken by the function is a  matrix
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
makeCacheMatrix
x<- matrix(c(4,3,3,2),2,2) # The matrix
makeCacheMatrix(x)
eval(makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) { #The object x, taken by the function is a  matrix
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## cacheSolve: "This function computes the inverse of the special "matrix" returned
## by makeCacheMatrix above. If the inverse has already been calculated (and the
##matrix has not changed), then the cachesolve should retrieve the inverse from
#the cache."
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x)) #Works as intended
cacheSolve(makeCacheMatrix(x)) #Works as intended
a<-makeCacheMatrix(x)
a$get
a$get()
ls(a)
ls(environment(a$get))
class(a)
m
a$m
class(a$get)
a
str(a)
a
ls(a)
?ls
?ls
objects(a)
a$get
b<-makecachematrix(x)
b<-makeCacheMatrix(x)
str(b)
ls(a$get)
environment((a$get))
a$get
a$get(x)
a$get()
a$setinverse
a$setinverse()
a$setinverse(solve)
a$setinverse(solve)
a$setinverse(solve)m
a$setinverse(solve) m
a$getinverse()
a$set
a$set()
a$get()
a<-makeCacheMatrix
a$get()
a<-makeCacheMatrix(x)
a$get()
b<-CacheSolve
b<-CacheSolve()
b<-CacheSolve(a)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
b<-CacheSolve()
b<-CacheSolve(a)
b<-cacheSolve()
b<-cacheSolve(a)
a$getinverse()
?return()
a$setinverse()
a$setinverse(solve)
str(a$setinverse(solve))
debug(makeCacheMatrix)
debug(makeCacheMatrix)
makeCacheMatrix <- function(x = matrix()) { # x, taken by the function is a  matrix
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x # Stores the value of the inputted matrix, access by a$get()
setinverse <- function(solve) m <<- solve
getinverse <- function() m # Stores the result (the inverse matrix)
list(set = set, get = get, #This list, with its 4 objects is the returned output
setinverse = setinverse,
getinverse = getinverse)
}
n
a$get()
a$set(matrix(c(1,2,3,4),2,2))
a$get()
##### Overall comments:
# makeCacheMatrix accepts a matrix, solves it to get its inverse, and returns a list of
# 4 objects, one of which is the inverse matrix
# cacheSolve requires the result of makeCacheMatrix, from which it cheks to see if an
# inverse matrix has been calculated. If so it is printed, otherwise the inverse is
# calculated.
#####
## In the comments the "inputted matrix" is the matrix we wish to find the inverse of;
## the "inverse matrix" is the result - i.e the inverse matrix of the "inputted matrix".
## "makeCacheMatrix: This function creates a special "matrix" object that can cache its
## inverse." (from the assignment description)
## Saving makeCacheMatrix to an object, i.e: a<-makeCacheMatrix, and then str(a) reveals
## that "a" is a list of 4, with each element of the list containing a function. Each
## element may be accessed like this e.g. a$get() returns matrix x.
makeCacheMatrix <- function(x = matrix()) { # x, taken by the function is a  matrix
inverse <- NULL
set <- function(y) { #"Set" changes the value of x, in the "outside" environment
x <<- y # Change happens here - as the "<<-" operator assigns the value of y to x,
# in an environment different to that of function set, such as the main
# function environment
inverse <<- NULL #If the matrix has been changed, the inverse must be recalculated
}
get <- function() x # Stores the value of the inputted matrix, access by a$get()
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse # Stores the result (the inverse matrix)
list(set = set, get = get, #This list, with its 4 objects is the returned output
setinverse = setinverse,
getinverse = getinverse)
}
a<-makeCacheMatrix(x)
## cacheSolve: "This function computes the inverse of the special "matrix" returned
## by makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then the cachesolve should retrieve the inverse from
#  the cache." (from the assignment description)
cacheSolve <- function(x, ...) { # Takes the output of makeCacheMatrix as an object
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse() # This line saves the stored value of the inverse matrix as "inverse"
if(!is.null(inverse)) { # If getinverse has a value, this is returned below
message("getting cached data")
return(inverse)
}
data <- x$get() #The following lines only appear to proceed if "inverse" was null
# implying that there wasn't a stored inverse matrix. In such a case:
## the inputted matrix is stored as "data" and then solved and saved as "inverse",
## and x$setinverse then takes the function solve as an argument
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse #Finally inverse is returned
}
# using the functions -----------------------------------------------------
# The functions may be run seperately i.e. a1<-makeCacheMatrix(a_matrix),
# b2<-cacheSolve(a1)
# Or in one step: inversematrix<-cacheSolve(makeCacheMatrix(a_matrix))
# An example showing use --------------------------------------------------
# An invertible matrix (source:http://www.mathwords.com/i/inverse_of_a_matrix.htm )
x<- matrix(c(4,3,3,2),2,2) # The matrix
x_inverse<-matrix (c(-2,3,3,-4),2,2)
identity_2x2<-matrix(c(1,0,0,1),2,2) # identity matrix
x %*% x_inverse # "true" matrix multiplication shows that x_inverse is the inverse
# of x, since the answer is identity
solve(x,identity_2x2) # documentation: "solves the equation a %*% x = b for x,
#where b can be either a vector or a matrix". In this case I am solving:
#x %*% x_inverse = identity_2x2 for x_inverse
cacheSolve(makeCacheMatrix(x)) #Works as intended, yielding the inverse matrix of x.
##### Overall comments:
# makeCacheMatrix accepts a matrix, solves it to get its inverse, and returns a list of
# 4 objects, one of which is the inverse matrix
# cacheSolve requires the result of makeCacheMatrix, from which it cheks to see if an
# inverse matrix has been calculated. If so it is printed, otherwise the inverse is
# calculated.
#####
## In the comments the "inputted matrix" is the matrix we wish to find the inverse of;
## the "inverse matrix" is the result - i.e the inverse matrix of the "inputted matrix".
## "makeCacheMatrix: This function creates a special "matrix" object that can cache its
## inverse." (from the assignment description)
## Saving makeCacheMatrix to an object, i.e: a<-makeCacheMatrix, and then str(a) reveals
## that "a" is a list of 4, with each element of the list containing a function. Each
## element may be accessed like this e.g. a$get() returns matrix x.
makeCacheMatrix <- function(x = matrix()) { # x, taken by the function is a  matrix
inverse <- NULL
set <- function(y) { #"Set" changes the value of x, in the "outside" environment
x <<- y # Change happens here - as the "<<-" operator assigns the value of y to x,
# in an environment different to that of function set, such as the main
# function environment
inverse <<- NULL #If the matrix has been changed, the inverse must be recalculated
}
get <- function() x # Stores the value of the inputted matrix, access by a$get()
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse # Stores the result (the inverse matrix)
list(set = set, get = get, #This list, with its 4 objects is the returned output
setinverse = setinverse,
getinverse = getinverse)
}
a<-makeCacheMatrix(x)
## cacheSolve: "This function computes the inverse of the special "matrix" returned
## by makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then the cachesolve should retrieve the inverse from
#  the cache." (from the assignment description)
cacheSolve <- function(x, ...) { # Takes the output of makeCacheMatrix as an object
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse() # The stored inverse matrix is assigned to "inverse"
if(!is.null(inverse)) { # If getinverse has a value, this is returned below
message("getting cached data")
return(inverse)
}
data <- x$get() #The following lines only appear to proceed if "inverse" was null
# implying that there wasn't a stored inverse matrix. In such a case:
## the inputted matrix is stored as "data" and then solved and saved as "inverse",
## and x$setinverse then takes the function solve as an argument
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse #Finally inverse is returned
}
# using the functions -----------------------------------------------------
# The functions may be run seperately i.e. a1<-makeCacheMatrix(a_matrix),
# b2<-cacheSolve(a1)
# Or in one step: inversematrix<-cacheSolve(makeCacheMatrix(a_matrix))
# An example showing use --------------------------------------------------
# An invertible matrix (source:http://www.mathwords.com/i/inverse_of_a_matrix.htm )
x<- matrix(c(4,3,3,2),2,2) # The matrix
x_inverse<-matrix (c(-2,3,3,-4),2,2)
identity_2x2<-matrix(c(1,0,0,1),2,2) # identity matrix
x %*% x_inverse # "true" matrix multiplication shows that x_inverse is the inverse
# of x, since the answer is identity
solve(x,identity_2x2) # documentation: "solves the equation a %*% x = b for x,
#where b can be either a vector or a matrix". In this case I am solving:
#x %*% x_inverse = identity_2x2 for x_inverse
cacheSolve(makeCacheMatrix(x)) #Works as intended, yielding the inverse matrix of x.
ls(rm)
ls(rm(environment))
?ls
?rm
rm(list=ls())
##### Overall comments:
# makeCacheMatrix accepts a matrix, solves it to get its inverse, and returns a list of
# 4 objects, one of which is the inverse matrix
# cacheSolve requires the result of makeCacheMatrix, from which it cheks to see if an
# inverse matrix has been calculated. If so it is printed, otherwise the inverse is
# calculated.
#####
## In the comments the "inputted matrix" is the matrix we wish to find the inverse of;
## the "inverse matrix" is the result - i.e the inverse matrix of the "inputted matrix".
## "makeCacheMatrix: This function creates a special "matrix" object that can cache its
## inverse." (from the assignment description)
## Saving makeCacheMatrix to an object, i.e: a<-makeCacheMatrix, and then str(a) reveals
## that "a" is a list of 4, with each element of the list containing a function. Each
## element may be accessed like this e.g. a$get() returns matrix x.
makeCacheMatrix <- function(x = matrix()) { # x, taken by the function is a  matrix
inverse <- NULL
set <- function(y) { #"Set" changes the value of x, in the "outside" environment
x <<- y # Change happens here - as the "<<-" operator assigns the value of y to x,
# in an environment different to that of function set, such as the main
# function environment
inverse <<- NULL #If the matrix has been changed, the inverse must be recalculated
}
get <- function() x # Stores the value of the inputted matrix, access by a$get()
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse # Stores the result (the inverse matrix)
list(set = set, get = get, #This list, with its 4 objects is the returned output
setinverse = setinverse,
getinverse = getinverse)
}
a<-makeCacheMatrix(x)
## cacheSolve: "This function computes the inverse of the special "matrix" returned
## by makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then the cachesolve should retrieve the inverse from
#  the cache." (from the assignment description)
cacheSolve <- function(x, ...) { # Takes the output of makeCacheMatrix as an object
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse() # The stored inverse matrix is assigned to "inverse"
if(!is.null(inverse)) { # If getinverse has a value, this is returned below
message("getting cached data")
return(inverse)
}
data <- x$get() #The following lines only appear to proceed if "inverse" was null
# implying that there wasn't a stored inverse matrix. In such a case:
## the inputted matrix is stored as "data" and then solved and saved as "inverse",
## and x$setinverse then takes the function solve as an argument
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse #Finally inverse is returned
}
# using the functions -----------------------------------------------------
# The functions may be run seperately i.e. a1<-makeCacheMatrix(a_matrix),
# b2<-cacheSolve(a1)
# Or in one step: inversematrix<-cacheSolve(makeCacheMatrix(a_matrix))
# An example showing use --------------------------------------------------
# An invertible matrix (source:http://www.mathwords.com/i/inverse_of_a_matrix.htm )
x<- matrix(c(4,3,3,2),2,2) # The matrix
x_inverse<-matrix (c(-2,3,3,-4),2,2)
identity_2x2<-matrix(c(1,0,0,1),2,2) # identity matrix
x %*% x_inverse # "true" matrix multiplication shows that x_inverse is the inverse
# of x, since the answer is identity
solve(x,identity_2x2) # documentation: "solves the equation a %*% x = b for x,
#where b can be either a vector or a matrix". In this case I am solving:
#x %*% x_inverse = identity_2x2 for x_inverse
cacheSolve(makeCacheMatrix(x)) #Works as intended, yielding the inverse matrix of x.
